class CameraThread(QThread):
    change_pixmap = pyqtSignal(object)
    connection_status = pyqtSignal(str)
    telemetry_data = pyqtSignal(dict)
    error_occurred = pyqtSignal(str)

    def __init__(self, source):
        super().__init__()
        self.source = source
        self._running = False
        self._recording = False
        self.out = None
        self.cap = None
        self.frame_count = 0
        self.last_frame_time = 0
        self.fps = 0

        # Параметры камеры
        self.camera_settings = {
            'brightness': 50,
            'contrast': 50,
            'saturation': 50,
            'exposure': 50,
            'hue': 50
        }

        # Наложения
        self.overlay_text = ""
        self.overlay_font = cv2.FONT_HERSHEY_SIMPLEX
        self.overlay_position = (10, 30)
        self.overlay_scale = 0.8
        self.overlay_color = (255, 255, 255)
        self.overlay_thickness = 2

        # Логотип
        self.logo = None
        self.logo_pos = (10, 10)
        self.logo_alpha = 1.0

    def run(self):
        self._running = True
        self.connect_to_camera()

        while self._running:
            ret, frame = self.cap.read()
            if ret:
                self.process_frame(frame)
            else:
                self.handle_read_error()

        self.cleanup()

    def connect_to_camera(self):
        try:
            self.cap = cv2.VideoCapture(self.source)

            if not self.cap.isOpened():
                raise Exception(f"Не удалось открыть источник: {self.source}")

            self.apply_initial_settings()
            self.connection_status.emit("connected")
            self.error_occurred.emit(f"Успешное подключение к {self.source}")

        except Exception as e:
            self.error_occurred.emit(f"Ошибка подключения: {str(e)}")
            self.connection_status.emit("disconnected")
            self._running = False

    def apply_initial_settings(self):
        for setting, value in self.camera_settings.items():
            self.set_camera_property(setting, value)

    def process_frame(self, frame):
        self.update_fps_counter()

        # Применяем настройки изображения
        frame = self.apply_image_settings(frame)

        # Добавляем наложения
        frame = self.apply_overlays(frame)

        # Конвертируем для отображения
        rgb_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        qt_image = QImage(rgb_image.data, w, h, bytes_per_line, QImage.Format_RGB888)

        self.change_pixmap.emit(qt_image)

        # Записываем если идет запись
        if self._recording and self.out is not None:
            self.out.write(frame)

        # Генерируем телеметрию
        self.generate_telemetry()

    def update_fps_counter(self):
        self.frame_count += 1
        current_time = time.time()
        if current_time - self.last_frame_time >= 1.0:
            self.fps = self.frame_count
            self.frame_count = 0
            self.last_frame_time = current_time

    def apply_image_settings(self, frame):
        # Яркость и контраст
        frame = cv2.convertScaleAbs(frame,
                                    alpha=self.camera_settings['contrast'] / 50.0,
                                    beta=self.camera_settings['brightness'] - 50)

        # Насыщенность
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        hsv[..., 1] = hsv[..., 1] * (self.camera_settings['saturation'] / 50.0)
        frame = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

        return frame

    def apply_overlays(self, frame):
        if self.overlay_text:
            cv2.putText(frame, self.overlay_text, self.overlay_position,
                        self.overlay_font, self.overlay_scale,
                        self.overlay_color, self.overlay_thickness)

        if self.logo is not None and self.logo_alpha > 0:
            frame = self.apply_logo(frame)

        return frame

    def apply_logo(self, frame):
        logo_resized = cv2.resize(self.logo, (100, 100))
        alpha = self.logo_alpha

        y1, y2 = self.logo_pos[1], self.logo_pos[1] + logo_resized.shape[0]
        x1, x2 = self.logo_pos[0], self.logo_pos[0] + logo_resized.shape[1]

        if y2 > frame.shape[0] or x2 > frame.shape[1]:
            return frame

        roi = frame[y1:y2, x1:x2]
        blended = cv2.addWeighted(logo_resized, alpha, roi, 1 - alpha, 0)
        frame[y1:y2, x1:x2] = blended

        return frame

    def handle_read_error(self):
        self.error_occurred.emit("Ошибка получения кадра. Попытка переподключения...")
        self.reconnect_camera()

    def reconnect_camera(self):
        self.cap.release()
        time.sleep(1)
        self.connect_to_camera()
        if not self._running:
            return

        # Если была запись, восстанавливаем ее
        if self._recording and self.out is not None:
            self.start_recording(self.out_filename)

    def cleanup(self):
        if self.cap is not None:
            self.cap.release()
        if self.out is not None:
            self.out.release()
        self.connection_status.emit("disconnected")

    def set_camera_property(self, property_name, value):
        prop_map = {
            'brightness': cv2.CAP_PROP_BRIGHTNESS,
            'contrast': cv2.CAP_PROP_CONTRAST,
            'saturation': cv2.CAP_PROP_SATURATION,
            'exposure': cv2.CAP_PROP_EXPOSURE,
            'hue': cv2.CAP_PROP_HUE
        }

        if property_name in prop_map:
            success = self.cap.set(prop_map[property_name], value)
            if success:
                self.camera_settings[property_name] = value
            return success
        return False

    def start_recording(self, filename):
        try:
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            fps = self.cap.get(cv2.CAP_PROP_FPS) or 30
            width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

            self.out = cv2.VideoWriter(filename, fourcc, fps, (width, height))
            self.out_filename = filename
            self._recording = True
            return True
        except Exception as e:
            self.error_occurred.emit(f"Ошибка начала записи: {str(e)}")
            return False

    def stop_recording(self):
        self._recording = False
        if self.out is not None:
            self.out.release()
            self.out = None

    def take_screenshot(self, filename):
        ret, frame = self.cap.read()
        if ret:
            try:
                cv2.imwrite(filename, frame)
                return True
            except Exception as e:
                self.error_occurred.emit(f"Ошибка сохранения снимка: {str(e)}")
        return False

    def generate_telemetry(self):
        telemetry = {
            'battery_level': np.random.randint(20, 100),
            'voltage': round(np.random.uniform(3.5, 4.2), 2),
            'signal_strength': np.random.randint(0, 100),
            'fps': self.fps,
            'status': 'OK' if np.random.random() > 0.1 else 'WARNING'
        }
        self.telemetry_data.emit(telemetry)

    def stop(self):
        self._running = False